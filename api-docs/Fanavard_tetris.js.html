<!DOCTYPE html>
<html lang="en">
<head>
    
    <meta charset="utf-8">
    <title>Fanavard/tetris.js - Documentation</title>
    
    
    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc.css">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav>
    
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="Storage.html">Storage</a><ul class='methods'><li data-type='method'><a href="Storage.html#.get">get</a></li><li data-type='method'><a href="Storage.html#.getArray">getArray</a></li><li data-type='method'><a href="Storage.html#.getInt">getInt</a></li><li data-type='method'><a href="Storage.html#.getJson">getJson</a></li><li data-type='method'><a href="Storage.html#.set">set</a></li></ul></li><li><a href="TetrisGame.html">TetrisGame</a></li><li><a href="Timer.html">Timer</a><ul class='methods'><li data-type='method'><a href="Timer.html#pause">pause</a></li><li data-type='method'><a href="Timer.html#resume">resume</a></li><li data-type='method'><a href="Timer.html#start">start</a></li></ul></li></ul><h3>Global</h3><ul><li><a href="global.html#addLanguage">addLanguage</a></li><li><a href="global.html#allowedInitTypes">allowedInitTypes</a></li><li><a href="global.html#allowInit">allowInit</a></li><li><a href="global.html#build">build</a></li><li><a href="global.html#buildDummy">buildDummy</a></li><li><a href="global.html#buildPlugIns">buildPlugIns</a></li><li><a href="global.html#checkLoad">checkLoad</a></li><li><a href="global.html#debugMode">debugMode</a></li><li><a href="global.html#deepExtend">deepExtend</a></li><li><a href="global.html#defaultLoadProperties">defaultLoadProperties</a></li><li><a href="global.html#defaultType">defaultType</a></li><li><a href="global.html#disableCache">disableCache</a></li><li><a href="global.html#init">init</a></li><li><a href="global.html#jRun">jRun</a></li><li><a href="global.html#loadedFiles">loadedFiles</a></li><li><a href="global.html#notAllowedUserAttributes">notAllowedUserAttributes</a></li><li><a href="global.html#plugins">plugins</a></li><li><a href="global.html#sanitizeName">sanitizeName</a></li><li><a href="global.html#setLoadedFlag">setLoadedFlag</a></li><li><a href="global.html#TetrisWords">TetrisWords</a></li><li><a href="global.html#urlPrefix">urlPrefix</a></li><li><a href="global.html#version">version</a></li></ul>
</nav>

<div id="main">
    
    <h1 class="page-title">Fanavard/tetris.js</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/* jshint browser: true */


//Create Object.assign method if it's not supported by default
//TODO: After moving classes to other files, Make this function load before any other
if (!Object.assign) {
    Object.defineProperty(Object, 'assign', {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function(target) {
            'use strict';
            if (target === undefined || target === null) {
                throw new TypeError('Cannot convert first argument to object');
            }

            let to = Object(target);
            for (let i = 1; i &lt; arguments.length; i++) {
                let nextSource = arguments[i];
                if (nextSource === undefined || nextSource === null) {
                    continue;
                }
                nextSource = Object(nextSource);

                let keysArray = Object.keys(nextSource);
                for (let nextIndex = 0, len = keysArray.length; nextIndex &lt; len; nextIndex++) {
                    let nextKey = keysArray[nextIndex];
                    let desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);
                    if (desc !== undefined &amp;&amp; desc.enumerable) {
                        to[nextKey] = nextSource[nextKey];
                    }
                }
            }
            return to;
        }
    });
}




/**
 * Storage Class
 * @static
 * @class Storage
 *
 *
 */
class Storage{

    /**
     * Returns a plain string of given key from localStorage
     * @param {string} key
     * @param {string} [default_value]
     * @returns {string | null | * | string}
     */
    static get(key, default_value) {
        default_value = default_value || "";
        return localStorage.getItem(key) || default_value;
    }

    /**
     * Returns an integer of given key from localStorage
     * @param {string} key
     * @param {string} default_value [default_value]
     * @returns {number}
     */
    static getInt(key, default_value) {
        default_value = default_value || 0;
        return Number(get(key, default_value));
    }

    /**
     * Returns an array of given key from localStorage
     * @param {string} key
     * @param {string} default_value [default_value]
     * @returns {array}
     */
    static getArray(key, default_value) {
        default_value = default_value || [];
        return JSON.parse(get(key),default_value);
    }

    /**
     * Returns an integer of given key from localStorage
     * @param {string} key
     * @param {string} default_value [default_value]
     * @returns {Object}
     */
    static getJson (key, default_value) {
        default_value = default_value || {};
        return JSON.parse(get(key),default_value);
    }

    /**
     * Saves an object in localStorage
     * @param {string} key
     * @param {Object} value
     */
    static set(key, value) {
        if (typeof (value)==="object"){
            value = JSON.stringify(value);
        }
        localStorage.setItem(key, value)
    }
}







/**
 @typedef {Object} TimerConfig
 @property {string} [cssClass=".timerDisplay"] - CssClass selecor for setting time in timerDisplay.
 @property {function}   onStart     - Event when timer get's started.
 @property {function}   onPause     - Event when timer get's paused.
 @property {function}   onResume    - Event when timer get's resumed.
 @property {Object}     blobTiming  - Blob for feeding WebWorker.
 @property {function}   workerOnMessage(event) - Callback function for WebWorker.onmessage .
 @property {function}   beatifySecond(seconds) - Function to make time beatiful.
 */

/**
 * A Timer class which use WebWorker to manage time.
 * @class Timer
 *
 * @constructor
 * @param {TimerConfig}
 *
 * @property timerWorker {WebWorker} WebWorker used in timer
 * @property config {TimerConfig}
 *
 *
 * @example
 *           let timer = new Timer({
 *               onStart: function(){
 *                   TetrisGame.initValues.paused = false;
 *               },
 *               workerOnMessage:function (event) {
 *                   Storage.set('seconds', event.data);
 *               },
 *               onPause:function () {
 *                   TetrisGame.initValues.paused = true;
 *               },
 *               onResume:function () {
 *                   TetrisGame.initValues.paused = false;
 *               },
 *               blobTiming: new Blob([document.querySelector('#workerTiming').textContent], { type: "text/javascript" });,
 *           });
 *
 *
 *
 */
class Timer{

    constructor(config){
        this.timerWorker=null;
        //Default config
        let defaultConfig = {
            cssClsss: ".timerDisplay",
            onStart: () => {},
            onPause: () => {},
            onResume:() => {},
            blobTiming: '',
            workerOnMessage: (event) =>{},
            beautifySecond: (s) =>{
                if (s > 3600) {
                    // 1 hour and 34 min
                    return (Math.ceil(s / 3600) + lang.hour + lang.and + s % 3600 + lang.min);
                } else if (s > 60 &amp;&amp; s &lt;= 3600) {
                    // 4 min and 3 s
                    return (Math.ceil(s / 60) + lang.minute + lang.and + s % 60 + lang.second);
                } else {
                    return (s + lang.second);
                }
            }
        };

        //Extend config
        this.config = Object.assign(defaultConfig,config);
    }


    /**
     * Starts the timer
     */

    start() {
        let timerDisplayEl = document.querySelector(this.config.cssClsss);
        if (typeof (Worker) !== "undefined") {
            if (!this.timerWorker) {
                this.timerWorker = new Worker(window.URL.createObjectURL(this.config.blobTiming));
            } else {
                // stop timer if running already
                this.pause();
            }

            this.timerWorker.onmessage = (event) => {
                timerDisplayEl.innerHTML = this.config.beautifySecond(event.data);
                this.config.workerOnMessage(event);
            };
            this.config.onStart();
        } else {
            timerDisplayEl.innerHTML = lang.webWorkerNotSupported;
        }
    };

    /**
     * Pauses the timer
     */
    pause() {
        this.timerWorker.postMessage({ 'pause_flag': true });
        this.config.onPause();
    };


    /**
     * Resumes the timer
     */

    resume() {
        this.timerWorker.postMessage({ 'pause_flag': false });
        this.config.onResume();
    };

}


/**
 * Main Tetris Game Class
 * @class
 */
var TetrisGame;
(function () {

    'use strict';

    var blobTiming,timer;

    let controlCodes = {
        DOWN: 40,
        LEFT: 37,
        RIGHT: 39
    };

    TetrisGame = {

        /**
         * Current version
         */
        version: '0.1.9',


        /**
         * Base config for game
         */
        config: {
            rows: 11,
            columnsMin: 6,
            columnsMax: 12,
            workingWordCount: 2,
            charSpeed: 1000,  // 1 second
            checkInRow: true,
            checkInColumn: false,
            animateHiding: true,
            playSoundOnSuccess: false,
            playSoundOnFailure: false,
            useLowercase: false,
            animateCharSpeed: 20
        },


        /**
         * Initialize variables
         */
        initValues: {
            paused: false,                 // is game paused
            finished: false,                // is game finished
            wordsFinished: false,           // do we run out of words

            validatedColumnsCount: 0,       // Count of columns which are validated
            nextChar: '',                   // Next character
            activeChar: {},                // Active character [not stopped] Object index
            choosedWords: [],               // Choosed words to work with them
            choosedWordsUsedChars: []      // Chars that used from choosed words
        },


        /**
         * Are we in browser env
         */
        isBrowser: (typeof window !== 'undefined'),


        /**
         * Game play board
         */
        playBoard: null,



        /**
         * Class Use to add new coming block
         */
        charBlock: function () {


            // if game is finished
            if (TetrisGame.initValues.finished) {
                document.querySelector(".showUpComingLetter").innerHTML = "";
                return false;
            }

            let charBlock = {};

            // choose random column to init char
            charBlock.column = Math.random() * TetrisGame.initValues.validatedColumnsCount &lt;&lt; 0;
            charBlock.row = 0;                               // top is 0 and bottom is max
            charBlock.name = TetrisGame.initValues.nextChar === "" ? TetrisGame.chooseChar() : TetrisGame.initValues.nextChar;        // char value
            charBlock.color = TetrisGame.materialColor();    // random material color
            charBlock.active = true;                         // character is animating on air
            charBlock.element = null;                        // holds our character element


            // move char
            charBlock.move = function (eventKeyCode) {

                var moveTo = {};
                var isBottomMove = false;


                switch (eventKeyCode) {
                    case controlCodes.LEFT:  // left
                        moveTo = {
                            row: charBlock.row,
                            column: charBlock.column + 1,
                            animateOutClass: (lang.rtl ? "fadeOutLeft" : "fadeOutRight"),
                            animateInClass: (lang.rtl ? "fadeInRight" : "fadeInLeft")
                        };
                        break;
                    case controlCodes.RIGHT:  // right
                        moveTo = {
                            row: charBlock.row,
                            column: charBlock.column - 1,
                            animateOutClass: (lang.rtl ? "fadeOutRight" : "fadeOutLeft"),
                            animateInClass: (lang.rtl ? "fadeInLeft" : "fadeInRight")
                        };
                        break;
                    case controlCodes.DOWN:  // down
                        moveTo = {
                            row: charBlock.row + 1,
                            column: charBlock.column,
                            animateOutClass: "fadeOutDown",
                            animateInClass: "fadeInDown"
                        };
                        isBottomMove = true;
                        break;
                    default:
                        return false;
                }


                // if move to is out of range
                if (moveTo.column >= TetrisGame.initValues.validatedColumnsCount || moveTo.column &lt; 0) {
                    return false;
                }


                var destinationEl = TetrisGame.playBoard.querySelector(".row_" + moveTo.row + " .column_" + moveTo.column) || null;
                if (moveTo.row >= TetrisGame.config.rows || (destinationEl.innerText.trim() !== "")) {

                    if (isBottomMove) {

                        // stop interval and request new char
                        clearInterval(charBlock.interval);

                        // check words
                        TetrisGame.checkWordSuccess(charBlock);

                        if (charBlock.row !== 0) {

                            if (TetrisGame.initValues.wordsFinished) {
                                TetrisGame.finishGame("finishWords");
                            } else {
                                // add new char
                                TetrisGame.characterFactory();
                            }
                        } else {
                            TetrisGame.finishGame("gameOver");
                        }
                    }

                } else {

                    // remove char with animation
                    charBlock.destroy(charBlock.element, moveTo.animateOutClass);

                    // update current char info
                    charBlock.row = moveTo.row;
                    charBlock.column = moveTo.column;
                    charBlock.animateInClass = moveTo.animateInClass;

                    // add our char in destination
                    TetrisGame.characterFactory(charBlock, destinationEl);
                }
            };


            // interval
            charBlock.interval = setInterval(function () {
                if (!TetrisGame.initValues.paused) {
                    charBlock.move(40);
                }
            }, TetrisGame.config.charSpeed);


            // destroy current character
            charBlock.destroy = function (workingElement, outgoingAnimation) {
                workingElement.className += " animated " + outgoingAnimation;
                setTimeout(function () {
                    // remove current char
                    workingElement.parentNode.removeChild(workingElement);
                }, 200);
            };


            // create and show up coming char
            TetrisGame.initValues.nextChar = TetrisGame.chooseChar();
            document.querySelector(".showUpComingLetter").innerHTML = TetrisGame.initValues.nextChar || "";

            // add this char to active chars
            TetrisGame.initValues.activeChar = charBlock;

            return charBlock;
        },


        /**
         * Choose a char of choosed words
         */
        chooseChar: function () {

            var choosedChar;
            var availableChars = TetrisGame.initValues.choosedWords.map(function (e) {
                return e ? e.word : ""
            }).join('');

            TetrisGame.initValues.choosedWordsUsedChars.forEach(function (value) {
                availableChars = availableChars.replace(value, '');
            });

            if (availableChars.length === 0) {
                let newWord = TetrisGame.chooseWord();
                if (newWord !== false) {
                    TetrisGame.initValues.choosedWords.push(newWord);
                    return TetrisGame.chooseChar();
                }
            } else {
                choosedChar = availableChars[Math.random() * availableChars.length &lt;&lt; 0];
                TetrisGame.initValues.choosedWordsUsedChars.push(choosedChar);

                return choosedChar;
            }
        },


        /**
         * Choose random words in game build to work with
         */
        chooseWord: function () {
            var keys = Object.keys(window.TetrisWords);
            var randomKey = keys[keys.length * Math.random() &lt;&lt; 0];
            var value = window.TetrisWords[randomKey];

            if (typeof value === "undefined" &amp;&amp; !TetrisGame.initValues.finished) {
                TetrisGame.initValues.wordsFinished = true;
                return false;
            }
            log(value);

            delete window.TetrisWords[randomKey];
            return value;
        },



        /**
         * Get a valid column number [min-max]
         */
        getValidColumnsNumber: function () {
            var columnsNumber = TetrisGame.config.columnsMin;
            for (var i = Object.keys(window.TetrisWords).length - 1; i >= 0; i--) {
                var thisWordLength = window.TetrisWords[i].word.length;
                if (thisWordLength > columnsNumber) {
                    columnsNumber = thisWordLength;
                }
            }
            columnsNumber = TetrisGame.config.columnsMax &lt; columnsNumber ? TetrisGame.config.columnsMax : columnsNumber;
            return columnsNumber % 2 === 0 ? columnsNumber : columnsNumber + 1;
        },



        /**
         * Check if could find a success word
         */
        checkWordSuccess: function (lastChar) {

            log("check word happens");
            // @todo : if okay : remove chars from Tetris.choosedWordsUsedChars and word from Tetris.choosedWords
        },


        /**
         * Get a random material color
         * @return {string}
         */
        materialColor: function () {
            // colors from https://github.com/egoist/color-lib/blob/master/color.json
            var colors = [
                "#ef5350",
                "#d32f2f",
                "#b71c1c",
                "#d50000",
                "#ec407a",
                "#e91e63",
                "#d81b60",
                "#c2185b",
                "#ad1457",
                "#880e4f",
                "#e91e63",
                "#f50057",
                "#c51162",
                "#ab47bc",
                "#9c27b0",
                "#8e24aa",
                "#7b1fa2",
                "#6a1b9a",
                "#4a148c",
                "#9c27b0",
                "#aa00ff",
                "#7e57c2",
                "#673ab7",
                "#5e35b1",
                "#512da8",
                "#4527a0",
                "#673ab7",
                "#7c4dff",
                "#651fff",
                "#6200ea",
                "#5c6bc0",
                "#3f51b5",
                "#3949ab",
                "#303f9f",
                "#283593",
                "#1a237e",
                "#3f51b5",
                "#536dfe",
                "#3d5afe",
                "#304ffe",
                "#1e88e5",
                "#1976d2",
                "#1565c0",
                "#0d47a1",
                "#2979ff",
                "#2962ff",
                "#0288d1",
                "#0277bd",
                "#01579b",
                "#0091ea",
                "#0097a7",
                "#00838f",
                "#006064",
                "#009688",
                "#00897b",
                "#00796b",
                "#00695c",
                "#004d40",
                "#4caf50",
                "#43a047",
                "#388e3c",
                "#2e7d32",
                "#7cb342",
                "#689f38",
                "#558b2f",
                "#33691e",
                "#9e9d24",
                "#ef6c00",
                "#e65100"
            ];
            var random = Math.random() * colors.length &lt;&lt; 0;
            return colors[random];
        },


        /**
         * Factory of character
         * @param char
         * @param initializeElement
         */
        characterFactory: function (char, initializeElement) {

            // if char is not supplied create new one
            if (typeof char === "undefined") {

                char = new TetrisGame.charBlock();

                if (Object.keys(char).length !== 0) {
                    initializeElement = TetrisGame.playBoard.querySelector(".row_" + char.row + " .column_" + char.column);
                } else {
                    return false;
                }
            }

            var charBlock = document.createElement('span');
            charBlock.style.background = char.color;
            charBlock.innerHTML = char.name;
            charBlock.className = "charBlock animated " + (char.animateInClass || "");

            char.element = charBlock;

            initializeElement.innerHTML = '';
            initializeElement.appendChild(charBlock);

        },

        buttonManager: function () {
            let gameBtnControl = document.querySelector(".gameControlButtons");
            gameBtnControl.querySelector(".pauseGame").style.display = "none";
            gameBtnControl.querySelector(".resumeGame").style.display = "inline-block";
        },


        /**
         * Start Game play
         */
        startGamePlay: function () {

            TetrisGame.playBoard = document.querySelector(".playBoard");

            // Get valid column length based on max json word length to create columns
            TetrisGame.initValues.validatedColumnsCount = TetrisGame.getValidColumnsNumber();

            // add class to have playBoard columns
            TetrisGame.playBoard.classList.add('is' + TetrisGame.initValues.validatedColumnsCount + 'Column');


            // create game columns and rows
            var playBoardTable = '';
            for (var r = 0; r &lt; TetrisGame.config.rows; r++) {
                playBoardTable += '&lt;div class="isRow row_' + r + '">';
                for (var c = 0; c &lt; TetrisGame.initValues.validatedColumnsCount; c++) {
                    playBoardTable += '&lt;div class="isColumn column_' + c + '" data-row="' + r + '">&lt;/div>';
                }
                playBoardTable += '&lt;/div>';
            }
            TetrisGame.playBoard.innerHTML = playBoardTable;


            // Choose n words from json to create rows and columns
            for (var i = 0; i &lt; TetrisGame.config.workingWordCount; i++) {
                TetrisGame.initValues.choosedWords.push(TetrisGame.chooseWord());
            }

            // start game timer
            TetrisGame.timer.start();


            // create first char block
            TetrisGame.characterFactory();



            // arrow keys press
            document.addEventListener("keydown", function (e) {
                TetrisGame.initValues.activeChar.move(e.keyCode);
            });


            let gameBtnControl = document.querySelector(".gameControlButtons");
            gameBtnControl.querySelector(".startGame").style.display = "none";
            gameBtnControl.querySelector(".pauseGame").style.display = "inline-block";
        },


        /**
         * Pause Game play
         * @todo : add resumeGamePlay
         */
        pauseGamePlay: function () {

            //TetrisGame.buttonManager()

            // stop timer [will stop whole game]
            TetrisGame.timer.pause();
        },


        /**
         * Resume Game play
         */
        resumeGamePlay: function () {

            //TetrisGame.buttonManager()


            // resume timer [will resume whole game]
            TetrisGame.timer.resume();
        },


        /**
         * Reset Game play
         */
        restartGamePlay: function () {
            TetrisGame.initValues = {
                paused: false,                 // is game paused
                finished: false,                // is game finished
                wordsFinished: false,           // do we run out of words

                validatedColumnsCount: 0,       // Count of columns which are validated
                nextChar: '',                   // Next character
                activeChar: {},                // Active character [not stopped] Object index
                choosedWords: [],               // Choosed words to work with them
                choosedWordsUsedChars: []      // Chars that used from choosed words
            };
            TetrisGame.build();
        },


        /**
         * Game is finished [gameOver OR finishWords]
         * @param mode
         */
        finishGame: function (mode) {

            let gameBtnControl = document.querySelector(".gameControlButtons");
            gameBtnControl.querySelector(".startGame,.pauseGame,.resumeGame").style.display = "none";
            gameBtnControl.querySelector(".restartGame").style.display = "inline-block";

            TetrisGame.initValues.finished = true;
            TetrisGame.timer.pause();


            if (mode === "gameOver") {
                alert("Game Over!");
            } else {
                alert("Finished words.");
            }


            // @todo : show modal

        },



        /**
         * Select editor element with class search emoji
         * @type {HTMLElement | null}
         */
        build: function () {

            // blob for timer
            blobTiming = new Blob([
                document.querySelector('#workerTiming').textContent
            ], { type: "text/javascript" });

            TetrisGame.timer = new Timer({
                blobTiming:blobTiming,
                onStart: function(){
                    TetrisGame.initValues.paused = false;
                },
                workerOnMessage:function (event) {
                    Storage.set('seconds', event.data);
                },
                onPause:function () {
                    TetrisGame.initValues.paused = true;
                },
                onResume:function () {
                    TetrisGame.initValues.paused = false;
                },

            });

            // make ltr if used lang is ltr
            let ltrClass = "";
            if (!lang.rtl) {
                ltrClass = "isLtr";

                // In LTR languages, Left and Right should be swapped
                let tmp = controlCodes.LEFT;
                controlCodes.LEFT = controlCodes.RIGHT;
                controlCodes.RIGHT = tmp;
            }



            // add main html to page
            document.querySelector("#container").innerHTML =
                `&lt;div class="gameHolder ${ltrClass}">
                    &lt;div class="behindPlayBoard">
                       &lt;div class="showUpComingLetter" title="${lang.nextLetter}:">&lt;/div>
                       &lt;div class="gameControlButtons" >
                            &lt;div onclick="TetrisGame.startGamePlay();" class="startGame">${lang.startGame}&lt;/div>
                            &lt;div onclick="TetrisGame.pauseGamePlay();" class="pauseGame" style="display: none">${lang.pauseGame}&lt;/div>
                            &lt;div onclick="TetrisGame.resumeGamePlay();" class="resumeGame" style="display: none">${lang.resumeGame}&lt;/div>
                            &lt;div onclick="TetrisGame.restartGamePlay();" class="restartGame" style="display: none">${lang.restartGame}&lt;/div>
                       &lt;/div>
                       &lt;div class="courseArea">
                           &lt;div >&lt;i class="linearicon linearicon-bag-pound">&lt;/i> ${lang.score} : 0&lt;/div>
                           &lt;div >&lt;i class="linearicon linearicon-mustache-glasses">&lt;/i> ${lang.createdWords} : 0&lt;/div>
                           &lt;div >&lt;i class="linearicon linearicon-clock">&lt;/i> ${lang.spentTime} : &lt;span class="timerDisplay">0&lt;/span>&lt;/div>
                       &lt;/div>
                   &lt;/div>
                   &lt;div class="playBoard">&lt;span class="emptyPlayBoard">${lang.clickStartGame}&lt;/span>&lt;/div>
                &lt;/div>
                &lt;footer class="page-footer">
                    &lt;div class="container">
                        &lt;i class="linearicon linearicon-brain">&lt;/i>  ${lang.copyRight}
                    &lt;/div>
                &lt;/footer>`;
        }
    };


    if (typeof module !== 'undefined' &amp;&amp; typeof module.exports !== 'undefined') {
        module.exports = TetrisGame;
    } else if (TetrisGame.isBrowser) {
        window.TetrisGame = TetrisGame;
    }

})();
</code></pre>
        </article>
    </section>




    
    
</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.5.5</a> on Fri Jul 06 2018 07:57:47 GMT+0430 (+0430) using the <a href="https://github.com/clenemt/docdash">docdash</a> theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/linenumber.js"></script>


</body>
</html>
